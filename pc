#!/bin/python3.6
'''
Author: Kyle Dixler
Finally discovered compiler design and the idea of abstract syntax trees
let's see where this goes.
'''

import curses
from curses import wrapper

UNDERLINE = "\033[4m"
NORMAL = "\033[0m"

class Node:
    """ Node class for the AST """
    def __init__(self, expression=''):
        self.raw = expression
        self.arg1 = self.arg2 = None
        if expression.replace('#', '').replace('.', '').isdigit():
            self.operation = expression
        else:
            if self.tok_split(expression, '+'):
                pass
            elif self.tok_split(expression, '-'):
                pass
            elif self.tok_split(expression, '*'):
                pass
            elif self.tok_split(expression, '/'):
                pass
            elif self.tok_split(expression, '^'):
                pass
            elif self.paren_split(expression):
                pass
                # use shortcircuit evaluation to
                # enforce precedence rules
                # if we're here, there's nothing to parse

    def paren_split(self, expression=''):
        """ todo """
        # since we like having cursors, we have to handle them
        if expression[0] == '(' \
           and expression[-1] == ')':
            self.operation = '('
            self.arg1 = Node(expression[1:-1])
        elif expression[0] == '#' \
           and expression[1] == '(' \
           and expression[-1] == ')':
            self.operation = '('
            self.arg1 = Node(expression[2:-1])
        elif expression[-1] == '#' \
           and expression[0] == '(' \
           and expression[-2] == ')':
            self.operation = '('
            self.arg1 = Node(expression[0:-2])
        else:
            return False
        return True

    def tok_split(self, expression='', token=''):
        """ todo """
        level = 0
        arg1 = arg2 = ''
        parse_first = True
        for i in expression:
            # level determination
            if i == '(':
                level += 1
            elif i == ')':
                level -= 1
            # if 0-level operate
            if level == 0 and parse_first:
                if i == token:
                    # we need to split the term
                    self.operation = i
                    parse_first = False
                    continue
            if parse_first:
                arg1 += i
            else:
                arg2 += i
        if not parse_first:
            # indicates that an addition was found
            self.arg1 = Node(arg1)
            self.arg2 = Node(arg2)
            return True
        return False

    def evaluate(self):
        """ todo """
        return eval(self.raw.replace("^", "**").replace("#", ''))

    def reformat(self):
        """ 2D conversion process """
        ################################################################
        # FUNCTION DECLARATIONS
        ################################################################

        #---------------------------------------------------------------
        # PADDING auxilliary function
        #---------------------------------------------------------------
        formatters = ['%', '/', '#']

        def filtered(line=''):
            """ return a string with the formatters removed """
            return ''.join([c if c not in formatters else '' for c in line])

        def pad(block1):
            """ pad a block to its largest line with spaces"""
            largest = max([len(filtered(i)) for i in block1])
            new_block = []
            for i in block1:
                new_block.append(i + ' '*(largest-len(i)))
            return new_block

        def pad_to(block1, block2):
            """ pad block1 to the length of block2 """
            largest1 = max([len(filtered(i)) for i in block1])
            largest = max([len(filtered(i)) for i in block2])
            if largest1 > largest:
                return pad(block1)

            new_block = []
            for i in block1:
                new_block.append(i+' '*(largest-len(filtered(i))))
            return new_block

        def prepad(block2, block1):
            """ todo """
            largest = max([len(filtered(i)) for i in block1])+1
            new_block = []
            for i in block2:
                new_block.append(' '*largest + i)
            return new_block

        def concat(mainline1, block1, mainline2, block2, operator):
            """
            #---------------------------------------------------------------
            # CONCATENATION [+|-|*]
            #---------------------------------------------------------------
            concatenate blocks together
            """
            def concat_prepad(block2, block1):
                """ pad by the other side so that they line up when concatenated"""
                largest = max([len(filtered(i)) for i in block1])
                new_block = []
                for i in block2:
                    new_block.append(' '*largest + i)
                return new_block

            # we want to concatenate both blocks at the mainline

            def concat_align(mainline1, block1, mainline2, block2):
                """ align block1 to block2 by vertical padding"""
                if mainline2 > mainline1:
                    # right higher than left
                    # calculate number of missing lines
                    # then pad left
                    missing_lines = mainline2-mainline1
                    padding = []
                    for i in range(0, missing_lines):
                        padding.append("")
                    padding = concat_prepad(padding, block1)
                    block1 = padding+block1
                    mainline1 = mainline2
                    # now they're equal
                return mainline1, block1

            mainline1, block1 = concat_align(mainline1, block1, mainline2, block2)
            mainline2, block2 = concat_align(mainline2, block2, mainline1, block1)

            # left equal to right
            new_block = pad(block1)
            for i in range(0, len(block2)):
                if i < len(new_block):
                    if i == mainline2:
                        new_block[i] += operator+block2[i]
                    else:
                        new_block[i] += ' '+block2[i]
                else:
                    block2 = prepad(block2, block1)
                    new_block += block2[i:]
                    break

            new_block = pad(new_block)
            return mainline1, new_block


        #---------------------------------------------------------------
        # DENOMINATION [/]
        #---------------------------------------------------------------
        def denom(mainline1, block1, mainline2, block2):
            """
            block1 is the numerator
            block2 is the denominator
            we need to concatenate these functions vertically
            in the correct position
            """

            # we must pad them flush to each other
            block1 = pad_to(block1, block2)
            block2 = pad_to(block2, block1)

            # pad the bottom line of the numerator
            block1[-1] = '%'+block1[-1]+'/'

            # concatenate the lists
            block = block1+block2
            return mainline1, block

        #---------------------------------------------------------------
        # EXPONENTIATION [^]
        #---------------------------------------------------------------
        def expo(mainline1, block1, mainline2, block2):
            """ we need to pad the blocks and then combine them """
            block1 = pad(block1)
            block2 = prepad(block2, block1)
            block1[mainline1] += '^'
            block = pad(block2+block1)

            return mainline1+len(block2), block

        #---------------------------------------------------------------
        # PARENTHESES [(]
        #---------------------------------------------------------------
        def paren(mainline1, block1):
            block1 = pad(block1)
            for i in range(0, len(block1)):
                if i == mainline1:
                    block1[i] = '('+block1[i]+')'
                else:
                    block1[i] = ' '+block1[i]+' '
            return mainline1, block1

        ################################################################
        # METHOD EXECUTION
        ################################################################
        if self.operation in ['+', '-', '*']:
            # perform horizontal concatenation
            mainline1, block1 = self.arg1.reformat()
            mainline2, block2 = self.arg2.reformat()
            return concat(mainline1, block1, mainline2, block2, self.operation)
        elif self.operation == '/':
            # perform vertical concatenation
            mainline1, block1 = self.arg1.reformat()
            mainline2, block2 = self.arg2.reformat()
            return denom(mainline1, block1, mainline2, block2)
        elif self.operation == '^':
            # perform diagonal concatenation
            mainline1, block1 = self.arg1.reformat()
            mainline2, block2 = self.arg2.reformat()
            return expo(mainline1, block1, mainline2, block2)
        elif self.operation in '(':
            # inject ()
            mainline, block = self.arg1.reformat()
            return paren(mainline, block)
        return 0, [self.operation]

def convert(expression='', pos=0):
    """ todo """
    try:
        if pos > 0:
            expression = expression[:pos-1]+'#'+expression[pos-1:]
        syntax_tree = Node(expression)
        solution = str(syntax_tree.evaluate())
        mainline, lst = syntax_tree.reformat()
        lst[mainline] = lst[mainline] + ' = ' + solution
        return lst
    except Exception as output:
        return [str(output)]

def main(stdscr):
    """ todo """
    # Clear screen
    backspace = 127
    position = 0
    line_lst = []

    while True:
        height, width = stdscr.getmaxyx()
        stdscr.move(int(position/width), position%width)
        cur_char = stdscr.getch()

        ################################################################
        # INPUT LINE
        ################################################################
        #---------------------------------------------------------------
        # DELETION
        #---------------------------------------------------------------
        if cur_char == backspace:
            if position > 0:
                # legal deletion
                if line_lst[position-1] == '(':
                    if position < len(line_lst) and line_lst[position] == ')':
                        line_lst.pop(position)

                line_lst.pop(position-1)
                position += -1
        elif cur_char == curses.KEY_DC:
            if position < len(line_lst):
                line_lst.pop(position)

        #---------------------------------------------------------------
        # NAVIGATION
        #---------------------------------------------------------------
        elif cur_char == curses.KEY_LEFT:
            if position > 0:
                position += -1
        elif cur_char == curses.KEY_RIGHT:
            if position < len(line_lst):
                position += 1
        elif cur_char in [curses.KEY_UP, curses.KEY_DOWN]:
            continue
        elif cur_char == curses.KEY_HOME:
            position = 0
        elif cur_char == curses.KEY_END:
            position = len(line_lst)
        #---------------------------------------------------------------
        # INSERTION
        #---------------------------------------------------------------
        else:
            # paren matching
            if chr(cur_char) == '(':
                # we add both
                line_lst.insert(position, '(')
                position += 1
                line_lst.insert(position, ')')
                position += -1
            elif chr(cur_char) == ')' and line_lst[position] == ')':
                # todo
                pass
            else:
                line_lst.insert(position, chr(cur_char))
            position += 1

        ################################################################
        # DRAWING
        ################################################################
        stdscr.clear()
        stdscr.move(0, 0)
        stdscr.addstr("".join(line_lst))
        stdscr.move(int(len("".join(line_lst))/width)+1, 0)
        at_cursor = False
        for cur_line in convert("".join(line_lst), position):
            for cur_char in cur_line:
                if cur_char == '%':
                    stdscr.attron(curses.A_UNDERLINE)
                elif cur_char == '/':
                    stdscr.attroff(curses.A_UNDERLINE)
                elif cur_char == '#':
                    stdscr.attron(curses.A_BOLD)
                    at_cursor = True
                else:
                    stdscr.addch(cur_char)
                    if at_cursor:
                        stdscr.attroff(curses.A_BOLD)
                        at_cursor = False
            stdscr.addch('\n')
    return

wrapper(main)

def output(expression=''):
    """ todo """
    syntax_tree = Node(expression)

    solution = str(syntax_tree.evaluate())
    mainline, lst = syntax_tree.reformat()
    print()
    for i in range(0, len(lst)):
        cur_line = lst[i].replace('%', UNDERLINE).replace('/', NORMAL)
        if i == mainline:
            cur_line += ' = ' + solution
        print(cur_line)
    return
