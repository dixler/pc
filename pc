#!/bin/python3.6
'''
Author: Kyle Dixler
Finally discovered compiler design and the idea of abstract syntax trees
let's see where this goes.
'''
underline = "\033[4m"
normal = "\033[0m"

class node:
    def __init__(self, expression=''):
        self.raw = expression
        self.arg1 = self.arg2 = None
        if expression.replace('#','').replace('.','').isdigit():
            self.op = expression
        else:
            for i in range(0,len(expression)):
                if self.tok_split(expression, '+') \
                or self.tok_split(expression, '-') \
                or self.tok_split(expression, '*') \
                or self.tok_split(expression, '/') \
                or self.tok_split(expression, '^') \
                or self.paren_split(expression):
                    # use shortcircuit evaluation to
                    # enforce precedence rules
                    # if we're here, there's nothing to parse
                    break
                
    def paren_split(self, expression=''):
        # since we like having cursors, we have to handle them
        if expression[0] == '(' \
           and expression[-1] == ')':
            self.op = '('
            self.arg1 = node(expression[1:-1])
        elif expression[0] == '#' \
           and expression[1] == '(' \
           and expression[-1] == ')':
            self.op = '('
            self.arg1 = node(expression[2:-1])
        elif expression[-1] == '#' \
           and expression[0] == '(' \
           and expression[-2] == ')':
            self.op = '('
            self.arg1 = node(expression[0:-2])
        else:
            return False
        return True
            
    def tok_split(self, expression='', token=''):
        level = 0
        arg1 = arg2 = ''
        parseFirst = True
        for i in expression:
            # level determination
            if i == '(':
                level += 1
            elif i == ')':
                level -= 1
            # if 0-level operate
            if level == 0 and parseFirst:
                if i == token:
                    # we need to split the term
                    self.op = i
                    parseFirst = False
                    continue
            if parseFirst:
                arg1 += i
            else:
                arg2 += i
        if parseFirst == False:
            # indicates that an addition was found
            self.arg1 = node(arg1)
            self.arg2 = node(arg2)
            return True

    def evaluate(self):
        return eval(self.raw.replace("^","**").replace("#",''))

    # 2D edition(testing with ^)
    def reformat(self):
        ################################################################
        # FUNCTION DECLARATIONS
        ################################################################

        #---------------------------------------------------------------
        # PADDING auxilliary function
        #---------------------------------------------------------------
        formatters = ['%','/','#']
        def filtered(line=''):
            return ''.join([c if c not in formatters else '' for c in line])
            return line.replace('%','').replace('/','').replace('#','')

        def pad(block1):
            largest = max([len(filtered(i)) for i in block1])
            newBlock = []
            for i in block1:
                newBlock.append(i + ' '*(largest-len(i)))
            return newBlock

        # if block1 larger than block2 return block1
        def padTo(block1,block2):
            largest1 = max([len(filtered(i)) for i in block1])
            largest = max([len(filtered(i)) for i in block2])
            if largest1 > largest:
                return block1

            newBlock = []
            for i in block1:
                newBlock.append(i+' '*(largest-len(filtered(i))))
            return newBlock

        def prepad(block2,block1):
            largest = max([len(filtered(i)) for i in block1])+1
            newBlock = []
            for i in block2:
                newBlock.append(' '*largest + i)
            return newBlock

        #---------------------------------------------------------------
        # CONCATENATION [+|-|*]
        #---------------------------------------------------------------
        def concat(mainline1, block1, mainline2, block2, op):
            def concat_prepad(block2,block1):
                largest = max([len(filtered(i)) for i in block1])
                newBlock = []
                for i in block2:
                    newBlock.append(' '*largest + i)
                return newBlock

            # we want to concatenate the highest line with the lower line
            # at the right position

            if mainline2 > mainline1:
                # right higher than left
                # calculate number of missing lines
                missingLines = mainline2-mainline1
                padding = []
                for i in range(0,missingLines):
                    padding.append("")
                padding = concat_prepad(padding, block1)
                block1 = padding+block1
                mainline1 = mainline2
                # now they're equal
            elif mainline1 > mainline2:
                # left higher than right
                # calculate number of missing lines
                missingLines = mainline1-mainline2
                padding = []
                for i in range(0,missingLines):
                    padding.append("")
                padding = concat_prepad(padding, block2)
                block2 = padding+block2
                mainline2 = mainline1
                # now they're equal

            # left equal to right
            newBlock = pad(block1)
            prePadded = False
            for i in range(0,len(block2)):
                if i < len(newBlock):
                    if i == mainline2:
                        newBlock[i] += op+block2[i]	# TODO
                    else:
                        newBlock[i] += ' '+block2[i]	# TODO
                else:
                    block2 = prepad(block2, block1)
                    newBlock += block2[i:]	# TODO
                    break

            newBlock = pad(newBlock)
            return mainline1,newBlock
                            

        #---------------------------------------------------------------
        # DENOMINATION [/]
        #---------------------------------------------------------------
        def denom(mainline1, block1, mainline2, block2):
            # block1 is the numerator
            # block2 is the denominator
            # we need to concatenate these functions vertically
            # in the correct position

            # we must pad them flush to each other
            block1 = padTo(block1,block2)
            block2 = padTo(block2,block1)

            # pad the bottom line of the numerator
            block1[-1] = '%'+block1[-1]+'/'

            # concatenate the lists
            block = block1+block2
            return mainline1,block

        #---------------------------------------------------------------
        # EXPONENTIATION [^]
        #---------------------------------------------------------------
        def expo(mainline1, block1, mainline2, block2):
            block1 = pad(block1)
            block2 = prepad(block2,block1)
            block1[mainline1] += '^'
            block = pad(block2+block1)

            return mainline1+len(block2),block

        #---------------------------------------------------------------
        # PARENTHESES [(]
        #---------------------------------------------------------------
        def paren(mainline1, block1):
            block1 = pad(block1)
            for i in range(0,len(block1)):
                if i == mainline1:
                    block1[i] = '('+block1[i]+')'
                else:
                    block1[i] = ' '+block1[i]+' '
            return mainline1,block1

        ################################################################
        # METHOD EXECUTION
        ################################################################
        if False:
            return 0,[self.op]
        elif self.op in ['+','-','*']:
            # perform concatenation
            mainline1, block1 = self.arg1.reformat()
            mainline2, block2 = self.arg2.reformat()
            return concat(mainline1, block1, mainline2, block2, self.op)
        elif self.op == '/':
            mainline1, block1 = self.arg1.reformat()
            mainline2, block2 = self.arg2.reformat()
            return denom(mainline1, block1, mainline2, block2)
        elif self.op == '^':
            mainline1, block1 = self.arg1.reformat()
            mainline2, block2 = self.arg2.reformat()
            return expo(mainline1, block1, mainline2, block2)
        elif self.op in '(':
            mainline, block = self.arg1.reformat()
            return paren(mainline,block)
        else:
            return 0,[self.op]

def convert(expression='',pos=0):
    try:
        if(pos > 0):
            expression = expression[:pos-1]+'#'+expression[pos-1:]
        syntax_tree = node(expression)
        solution = str(syntax_tree.evaluate())
        mainline,lst = syntax_tree.reformat()
        lst[mainline] = lst[mainline] + ' = ' + solution
        return lst
    except Exception as e:
        return [str(e)]

import curses
from curses import wrapper

def main(stdscr):
    # Clear screen
    BACKSPACE = 127
    position = 0
    line_lst = []

    while True:
        height,width=stdscr.getmaxyx()
        stdscr.move(int(position/width),position%width)
        cur_char = stdscr.getch()
        
        ################################################################
        # INPUT LINE
        ################################################################
        #---------------------------------------------------------------
        # DELETION
        #---------------------------------------------------------------
        if cur_char == BACKSPACE:
            if position > 0:
                # legal deletion
                if line_lst[position-1] == '(':
                    if position < len(line_lst) and line_lst[position] == ')':
                        line_lst.pop(position)

                line_lst.pop(position-1)
                position += -1
        elif cur_char == curses.KEY_DC:
            if position < len(line_lst):
                line_lst.pop(position)

        #---------------------------------------------------------------
        # NAVIGATION
        #---------------------------------------------------------------
        elif cur_char == curses.KEY_LEFT:
            if position > 0:
                position += -1
        elif cur_char == curses.KEY_RIGHT:
            if position < len(line_lst):
                position += 1
        elif cur_char in [curses.KEY_UP,curses.KEY_DOWN]:
            continue
        elif cur_char == curses.KEY_HOME:
            position = 0
        elif cur_char == curses.KEY_END:
            position = len(line_lst)
        #---------------------------------------------------------------
        # INSERTION
        #---------------------------------------------------------------
        else:
            # paren matching
            if chr(cur_char) == '(':
                # we add both
                line_lst.insert(position,'(')
                position += 1
                line_lst.insert(position,')')
                position += -1
            elif chr(cur_char) == ')' and line_lst[position-1] == ')':
                pass
            else:
                line_lst.insert(position,chr(cur_char))
            position += 1

        ################################################################
        # DRAWING
        ################################################################
        stdscr.clear()
        stdscr.move(0,0)
        stdscr.addstr("".join(line_lst))
        stdscr.move(int(len("".join(line_lst))/width)+1,0)
        atCursor = False
        for cur_line in convert("".join(line_lst),position):
            for cur_char in cur_line:
                if cur_char == '%':
                    stdscr.attron(curses.A_UNDERLINE)
                elif cur_char == '/':
                    stdscr.attroff(curses.A_UNDERLINE)
                elif cur_char == '#':
                    stdscr.attron(curses.A_BOLD)
                    atCursor = True
                else:
                    stdscr.addch(cur_char)
                    if atCursor:
                        stdscr.attroff(curses.A_BOLD)
                        atCursor = False
            stdscr.addch('\n')
    
    return

wrapper(main)

from decimal import Decimal
def output(expression=''):
    syntax_tree = node(expression)

    solution = str(syntax_tree.evaluate())
    #solution = '%.2E' % Decimal(solution)
    mainline,lst = syntax_tree.reformat()
    print()
    for i in range(0,len(lst)):
        cur_line = lst[i].replace('%',underline).replace('/',normal)
        if i == mainline:
            cur_line += ' = ' + solution + '==' + str(syntax_tree.treeEval())
        print(cur_line)
    return

